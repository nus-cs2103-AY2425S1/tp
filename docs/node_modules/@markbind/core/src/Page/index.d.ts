/// <reference types="cheerio" />
/// <reference types="node" />
import type { PageAssets, PageConfig } from './PageConfig';
import type { SiteConfig } from '../Site/SiteConfig';
import type { FrontMatter } from '../plugins/Plugin';
import type { ExternalManager } from '../External/ExternalManager';
export declare class Page {
    pageConfig: PageConfig;
    siteConfig: SiteConfig;
    asset: PageAssets;
    pageUserScriptsAndStyles: string[];
    frontmatter: FrontMatter;
    headerIdMap: Record<string, number>;
    includedFiles: Set<string>;
    headings: Record<string, string>;
    keywords: Record<string, string[]>;
    navigableHeadings: {
        [id: string]: {
            text: string;
            level: number;
        };
    };
    title?: string;
    layout?: string;
    constructor(pageConfig: PageConfig, siteConfig: SiteConfig);
    /**
     * Resets or initialises all stateful variables of the page,
     * which differs from one page generation call to another.
     */
    resetState(): void;
    /**
     * Checks if the provided filePath is a dependency of the page
     * @param {string} filePath to check
     */
    isDependency(filePath: string): boolean;
    prepareTemplateData(content: string): {
        asset: {
            bootstrap: string;
            externalScripts: string[];
            fontAwesome?: string | undefined;
            glyphicons?: string | undefined;
            octicons?: string | undefined;
            materialIcons?: string | undefined;
            bootstrapIcons?: string | undefined;
            highlight: string;
            markBindCss: string;
            markBindJs: string;
            pageNavCss: string;
            siteNavCss: string;
            bootstrapUtilityJs: string;
            polyfillJs: string;
            vue: string;
            pageVueRenderJs?: string | undefined;
            layoutUserScriptsAndStyles: string[];
            pluginScripts?: string[] | undefined;
            pluginLinks?: string[] | undefined;
        };
        baseUrl: string;
        content: string;
        pageUserScriptsAndStyles: string;
        layoutUserScriptsAndStyles: string;
        hasPageNavHeadings: boolean;
        dev: boolean;
        faviconUrl: string | undefined;
        markBindVersion: string;
        title: string | undefined;
        enableSearch: boolean;
    };
    /**
     * Filters out icon asset files that are not used in a page.
     * Pre-vue HTML does not include the actual HTML of vue components after rendering,
     * and post-vue HTML does not include HTML of popups (e.g. trigger, modals).
     * Hence, we need to process both HTML content here.
     * @param preVueSsrHtml html content of the page before processing Vue components
     * @param postVueSsrHtml html content of the page after processing Vue components
     */
    filterIconAssets(preVueSsrHtml: string, postVueSsrHtml: string): void;
    /**
     * Checks if page.frontmatter has a valid page navigation specifier
     */
    isPageNavigationSpecifierValid(): any;
    /**
     * Generates element selector for page navigation, depending on specifier in frontmatter
     * @param pageNav {string|number} 'default' refers to the configured heading indexing level,
     * otherwise a number that indicates the indexing level.
     */
    generateElementSelectorForPageNav(pageNav: string | number): string | undefined;
    /**
     * Collect headings outside of models and unexpanded panels.
     * Collects headings from the header slots of unexpanded panels, but not its content.
     * @param content html content of a page
     */
    collectNavigableHeadings(content: string): void;
    _collectNavigableHeadings($: cheerio.Root, context: cheerio.Element, pageNavSelector: string): void;
    /**
     * Records headings and keywords inside rendered page into this.headings and this.keywords respectively
     */
    collectHeadingsAndKeywords(pageContent: string): void;
    /**
     * Records headings and keywords inside content into this.headings and this.keywords respectively
     */
    collectHeadingsAndKeywordsInContent(content: string | Buffer, lastHeading: cheerio.Element | null, excludeHeadings: boolean, sourceTraversalStack: string[]): void;
    /**
     * Links a keyword to a heading
     * @param $ a Cheerio object
     * @param keyword to link
     * @param heading to link
     */
    linkKeywordToHeading($: cheerio.Root, keyword: cheerio.Element, heading: cheerio.Element | null): void;
    /**
     * Uses the collected frontmatter from {@link collectFrontmatter} to extract the {@link Page}'s
     * instance configurations.
     * Frontmatter properties always have lower priority than site configuration properties.
     */
    processFrontmatter(frontmatter: FrontMatter): void;
    /**
     *  Generates page navigation's heading list HTML
     *
     *  A stack is used to maintain proper indentation levels for the headings at different heading levels.
     */
    generatePageNavHeadingHtml(): string;
    /**
     * Generates page navigation's header if specified in this.frontmatter
     * @returns string string
     */
    generatePageNavTitleHtml(): string;
    /**
     *  Builds page navigation bar with headings up to headingIndexingLevel
     */
    buildPageNav(content: string): string;
    generate(externalManager: ExternalManager): Promise<void>;
    outputPageHtml(content: string): Promise<void>;
    /**
     * Generates a selector for headings with level inside the headingIndexLevel
     * or with the index attribute, that do not also have the noindex attribute
     * @param headingIndexingLevel to generate
     */
    static generateHeadingSelector(headingIndexingLevel: number): string;
    /**
     * Gets the closest heading to an element
     * @param $ a Cheerio object
     * @param headingsSelector jQuery selector for selecting headings
     * @param element to find closest heading
     */
    static getClosestHeading($: cheerio.Root, headingsSelector: string, element: cheerio.Element): cheerio.Element | null;
}
//# sourceMappingURL=index.d.ts.map