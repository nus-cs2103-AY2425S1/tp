"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SiteLinkManager = void 0;
const has_1 = __importDefault(require("lodash/has"));
const linkProcessor = __importStar(require("./linkProcessor"));
const headerProcessor_1 = require("./headerProcessor");
const _ = { has: has_1.default };
const tagsToValidate = new Set([
    'img',
    'pic',
    'thumbnail',
    'a',
    'link',
    'script',
]);
class SiteLinkManager {
    constructor(config) {
        this.config = config;
        this.intralinkCollection = new Map();
        this.filePathToHashesMap = new Map();
    }
    /**
     * Adds a resourcePath and cwf to the intralinkCollection,
     * ensuring each pair of (resourcePath, cwf) appears only once
     */
    _addToCollection(resourcePath, cwf) {
        if (!this.intralinkCollection.has(cwf)) {
            this.intralinkCollection.set(cwf, new Set());
        }
        // We have checked and set cwf in intralinkCollection above
        this.intralinkCollection.get(cwf).add(resourcePath);
    }
    validateAllIntralinks() {
        if (!this.config.intrasiteLinkValidation.enabled) {
            return;
        }
        this.intralinkCollection.forEach((resourcePaths, cwf) => {
            resourcePaths.forEach(resourcePath => linkProcessor.validateIntraLink(resourcePath, cwf, this.config, this.filePathToHashesMap));
        });
        this.intralinkCollection = new Map();
    }
    /**
     * Add a link to the intralinkCollection to be validated later,
     * if the node should be validated and intralink validation is not disabled.
     */
    collectIntraLinkToValidate(node, cwf) {
        if (!tagsToValidate.has(node.name)) {
            return 'Should not validate';
        }
        const hasIntralinkValidationDisabled = _.has(node.attribs, 'no-validation');
        if (hasIntralinkValidationDisabled) {
            return 'Intralink validation disabled';
        }
        const resourcePath = linkProcessor.getDefaultTagsResourcePath(node);
        if (!resourcePath || !linkProcessor.isIntraLink(resourcePath)) {
            return 'Should not validate';
        }
        this._addToCollection(resourcePath, cwf);
        return 'Intralink collected to be validated later';
    }
    /**
     * Add sections that could be reached by intra-link with hash to this node to filePathToHashesMap,
     * The reachable sections include nodes with ids and headings.
     */
    maintainFilePathToHashesMap(node, cwf) {
        if (!this.config.intrasiteLinkValidation.enabled) {
            return;
        }
        const path = cwf.substring(this.config.rootPath.length);
        if (!this.filePathToHashesMap.has(path)) {
            this.filePathToHashesMap.set(path, new Set());
        }
        if (node.attribs.id) {
            this.filePathToHashesMap.get(path).add(node.attribs.id);
        }
    }
    /**
     * Recursively add reachable sections of the included node to the filePathToHashesMap for validation.
     */
    maintainHashesForInclude(node, cwf) {
        if (!this.config.intrasiteLinkValidation.enabled) {
            return;
        }
        const isHeadingTag = (/^h[1-6]$/).test(node.name);
        if (isHeadingTag && node.attribs && !node.attribs.id) {
            (0, headerProcessor_1.setHeadingId)(node, this.config, false);
            this.maintainFilePathToHashesMap(node, cwf);
            node.attribs.id = undefined;
        }
        if (node.attribs && node.attribs.id) {
            this.maintainFilePathToHashesMap(node, cwf);
        }
        if (node.children) {
            node.children.forEach((child) => {
                this.maintainHashesForInclude(child, cwf);
            });
        }
    }
}
exports.SiteLinkManager = SiteLinkManager;
//# sourceMappingURL=SiteLinkManager.js.map