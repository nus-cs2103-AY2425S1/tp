"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdAttributeRenderer = void 0;
const has_1 = __importDefault(require("lodash/has"));
const vueSlotSyntaxProcessor_1 = require("./vueSlotSyntaxProcessor");
const logger = __importStar(require("../utils/logger"));
const elements_1 = require("./elements");
const node_1 = require("../utils/node");
const _ = {
    has: has_1.default,
};
/**
 * Class that is responsible for rendering markdown-in-attributes
 */
class MdAttributeRenderer {
    constructor(mdp) {
        this.markdownProcessor = mdp;
    }
    /**
     * Processes the markdown attribute of the provided element, inserting the corresponding <slot> child
     * if there is no pre-existing slot child with the name of the attribute present.
     * @param node Element to process
     * @param attribute Attribute name to process
     * @param isInline Whether to process the attribute with only inline markdown-it rules
     * @param slotName Name attribute of the <slot> element to insert, which defaults to the attribute name
     */
    processAttributeWithoutOverride(node, attribute, isInline, slotName = attribute) {
        const hasAttributeSlot = node.children
            && node.children.some(child => (0, vueSlotSyntaxProcessor_1.getVslotShorthandName)(child) === slotName);
        if (!hasAttributeSlot && _.has(node.attribs, attribute)) {
            let rendered;
            if (isInline) {
                rendered = this.markdownProcessor.renderMdInline(node.attribs[attribute]);
            }
            else {
                rendered = this.markdownProcessor.renderMd(node.attribs[attribute]);
            }
            const attributeSlotElement = (0, elements_1.createSlotTemplateNode)(slotName, rendered);
            node.children = node.children
                ? attributeSlotElement.concat(node.children)
                : attributeSlotElement;
        }
        delete node.attribs[attribute];
    }
    /**
     * Checks if the node has both the given slot and the given attribute,
     * deleting the attribute and logging a warning if both the slot and attribute exist.
     * @param node Element to process
     * @param attribute Attribute name to process
     * @param slotName Name attribute of the <slot> element to insert, which defaults to the attribute name
     * @returns {boolean} whether the node has both the slot and attribute
     */
    // eslint-disable-next-line class-methods-use-this
    hasSlotOverridingAttribute(node, attribute, slotName = attribute) {
        const hasNamedSlot = node.children
            && node.children.some(child => (0, vueSlotSyntaxProcessor_1.getVslotShorthandName)(child) === slotName);
        if (!hasNamedSlot || !node.attribs) {
            return false;
        }
        // If the slot is present, remove the attribute as the attribute has no effect.
        const hasAttribute = _.has(node.attribs, attribute);
        if (hasAttribute) {
            logger.warn(`${node.name} has a ${slotName} slot, '${attribute}' attribute has no effect.`);
            delete node.attribs[attribute];
        }
        return hasAttribute;
    }
    /**
     * Checks if there is a pre-existing slot for the attribute.
     * If there is a slot, it deletes the attribute and logs a warning.
     * If there is no slot, it processes the markdown attribute.
     * @param node Element to process
     * @param attribute Attribute name to process
     * @param isInline Whether to process the attribute with only inline markdown-it rules
     * @param slotName Name attribute of the <slot> element to insert, which defaults to the attribute name
     */
    processSlotAttribute(node, attribute, isInline, slotName = attribute) {
        if (!this.hasSlotOverridingAttribute(node, attribute, slotName)) {
            this.processAttributeWithoutOverride(node, attribute, isInline, slotName);
        }
    }
    processPopoverAttributes(node) {
        this.processSlotAttribute(node, 'header', true);
        // Warn if there is a content slot overriding the attributes 'content' or 'src'
        const hasSlotAndContentAttribute = this.hasSlotOverridingAttribute(node, 'content', 'content');
        const hasSlotAndSrcAttribute = this.hasSlotOverridingAttribute(node, 'src', 'content');
        if (hasSlotAndContentAttribute || hasSlotAndSrcAttribute) {
            return;
        }
        if (_.has(node.attribs, 'content') && _.has(node.attribs, 'src')) {
            logger.warn(`${node.name} has a 'content' attribute, 'src' attribute has no effect.`);
            delete node.attribs.src;
        }
        this.processAttributeWithoutOverride(node, 'content', true);
    }
    processTooltip(node) {
        this.processSlotAttribute(node, 'content', true);
    }
    processModalAttributes(node) {
        this.processSlotAttribute(node, 'header', true);
    }
    /*
     * Panels
     */
    processPanelAttributes(node) {
        this.processSlotAttribute(node, 'alt', false, '_alt');
        this.processSlotAttribute(node, 'header', false);
    }
    /*
     * Questions, QOption, and Quizzes
     */
    processQuestion(node) {
        this.processSlotAttribute(node, 'header', false);
        this.processSlotAttribute(node, 'hint', false);
        this.processSlotAttribute(node, 'answer', false);
    }
    processQOption(node) {
        this.processSlotAttribute(node, 'reason', false);
    }
    processQuiz(node) {
        this.processSlotAttribute(node, 'intro', false);
    }
    /*
     * Tabs
     */
    processTabAttributes(node) {
        this.processSlotAttribute(node, 'header', true);
    }
    /*
     * Boxes
     */
    processBoxAttributes(node) {
        this.processSlotAttribute(node, 'icon', true);
        this.processSlotAttribute(node, 'header', false);
    }
    /*
     * Dropdowns
     */
    processDropdownAttributes(node) {
        this.processSlotAttribute(node, 'header', true);
    }
    /**
     * Thumbnails
     */
    processThumbnailAttributes(node) {
        if (!node.attribs) {
            return;
        }
        const isImage = _.has(node.attribs, 'src') && node.attribs.src !== '';
        if (isImage) {
            return;
        }
        const text = _.has(node.attribs, 'text') ? node.attribs.text : '';
        if (text === '') {
            return;
        }
        const renderedText = this.markdownProcessor.renderMdInline(text);
        node.children = (0, node_1.parseHTML)(renderedText);
        delete node.attribs.text;
    }
    processScrollTopButtonAttributes(node) {
        this.processSlotAttribute(node, 'icon', true);
    }
    processAnnotationPointAttributes(node) {
        this.processSlotAttribute(node, 'content', false);
        this.processSlotAttribute(node, 'header', false);
        this.processSlotAttribute(node, 'label', false);
    }
}
exports.MdAttributeRenderer = MdAttributeRenderer;
//# sourceMappingURL=MdAttributeRenderer.js.map